import gi
gi.require_version('Gst', '1.0')
gi.require_version('GstAudio', '1.0')
from gi.repository import Gst
import argparse
import os
import json
from .pipeline import GstHomeAudioPipeline
from .xml_parse import xml_to_json, get_endpoints
from .settings import gst_home_audio_settings

VERSION_MAJOR  = 0
VERSION_MINOR  = 9
VERSION_BUGFIX = 9

PREAMBLE = """
Dolby Atmos for home audio executable
Version %d.%d.%d

Supported formats:
    Dolby Digital:      .ac3
    Dolby Digital Plus: .ec3, .eb3 

""" % (VERSION_MAJOR, VERSION_MINOR, VERSION_BUGFIX)

ALLOWED_SPEAKER_NAMES = ["lr", "c", "lfe", "lrs", "lrrs", "lre", "lrse",
                         "lrrse", "lrtm", "lrtf", "lrtr", "sh"]

ALLOWED_FILE_EXTENSIONS = [".ac3", ".ec3", ".eb3", ".xml"]

SPEAKER_PRESENCE_HELP_STR = """\
Defines speaker presence. Provide a list of speakers
in the output configuration. By default only Left/Right
speakers are enabled. Options are:
lr
    Left/Right speaker
    (default state: on)
c
    Center speaker
lfe
    Low-frequency effects channel
lrs
    Left/Right surround speakers
lrrs
    Left/Right rear surround speakers
lrtf
    Left/Right top front speakers
lrtm
    Left/Right top middle speakers
lrtr
    Left/Right top rear speakers
lre
    Left/Right Dolby Atmos enabled speakers
lrse
    Left/Right surround Dolby Atmos enabled speakers
lrrse
    Left/Right rear surround Dolby Atmos enabled speakers
sh
    Single height speaker
EXAMPLE:
    --speakers lr:c:lfe:lre

"""

DTT_XML_HELP_STR = """\
Loads the configuration .xml file generated by tuning tool.
Options are:
file=<filename>
    File with configuration.
endpoint=<name>
    Name of the endpoint configuration from provided .xml file.
profile=<name>
    Name of the profile from provided .xml file.
virt=<enable|disable>
    Loads configuration with virtualization enabled or disabled.
    (default value: disabled)
EXAMPLE:
    --xml-config file=example.xml:endpoint=name:virt=enable

"""

DRC_HELP_STR = """\
Dynamic range control. Options are:
mode=<enable|disable|auto>
    DRC mode for Dolby Digital Plus decoder.
    (default value: enable)
x=<0.0-1.0>
    Dynamic range compression cut scale factor.
    (default value: 1.0)
y=<0.0-1.0>
    Dynamic range compression boost scale factor.
    (default value: 1.0)
EXAMPLE:
    --drc mode=enable:x=0.5:y=0.5

"""


def parse_command_line():
    """
    Command line interface parser.

    Returns:
        args: A ::class::`argparse.Namespace` instance holding command line
            arguments and their values.
    """
    parser = argparse.ArgumentParser(prog='gst-ha-dap',
                                     formatter_class=argparse.RawTextHelpFormatter)
    config_group = parser.add_mutually_exclusive_group()
    parser.add_argument('-wd',
                        '--working_dir',
                        type=str,
                        help=argparse.SUPPRESS,
                        required=True)
    parser.add_argument('-i',
                        '--input',
                        help='Input file name.\n'
                             'Provide an input signal to decode, or an XML '
                             'configuration file to \n'
                             'convert to JSON format.\n'
                             'Supported formats:\n'
                             'Dolby Digital:      .ac3\n'
                             'Dolby Digital Plus: .ec3, .eb3\n'
                             'XML Configuration:  .xml\n\n',
                        type=str,
                        metavar='<filename>',
                        required=True)
    parser.add_argument('-o',
                        '--output',
                        type=str,
                        metavar='<filename>',
                        help='Defines the output WAV/JSON file name.\n'
                             '(default value: out.wav or out.json)\n\n',
                        default='out.wav')
    config_group.add_argument('-c',
                              '--config',
                              type=str,
                              metavar='<filename>',
                              help='Loads the configuration .json file.\n\n')
    config_group.add_argument('-x',
                              '--xml-config',
                              type=str,
                              metavar='<=option1:option2:...>',
                              help=DTT_XML_HELP_STR)
    parser.add_argument('-d',
                        '--drc',
                        help=DRC_HELP_STR,
                        type=str,
                        metavar='<=option1:option2:...>',
                        default='mode=enable:x=1:y=1')
    parser.add_argument('-s',
                        '--speakers',
                        help=SPEAKER_PRESENCE_HELP_STR,
                        type=str,
                        metavar='<=option1:option2:...>',
                        default='lr')
    parser.add_argument('--debug',
                        action='store_true',
                        default=False,
                        help=argparse.SUPPRESS)
    parser.add_argument('-gd',
                        '--gst_debug',
                        help="Number specyfing Gstreamer Debug Level",
                        type=int,
                        metavar='<val>',
                        default=0)
    parser.add_argument('-pg',
                        '--pipeline_graph',
                        help='Defines debug dot file name \n',
                        type=str,
                        metavar='<filename>',
                        default=None)

    print(PREAMBLE)

    return parser.parse_args()


def validate_command_line(args):
    """
    Validates the correctness of command line arguments.

    Args:
        args: A ::class::`argparse.Namespace` instance with command line
            arguments and their values.

    Returns:
        status: True if the validation was successful, else False.
        message: Error message if the validation failed.
    """
    if not os.path.isfile(args.input):
        return False, "Cannot open input file: %s" % args.input
    _, ext = os.path.splitext(args.input)
    if ext not in ALLOWED_FILE_EXTENSIONS:
        return False, "Unsupported input file format: %s" % ext

    if args.input.endswith("xml"):
        if args.output == 'out.wav':
            # Change the default name
            args.output = 'out.json'
        elif not args.output.endswith("json"):
            return False, ("The output file extension in XML conversion mode "
                           "must be .json")

    if args.speakers != 'lr':
        speaker_list = args.speakers.split(':')
        if not all(elem in ALLOWED_SPEAKER_NAMES for elem in speaker_list):
            return False, "Invalid speaker names provided."

    if args.drc != 'mode=enable:x=1:y=1':
        for sets in args.drc.split(':'):
            option = sets.split('=')
            if not option[0] in ['mode', 'x', 'y']:
                return False, "Invalid option: %s" % option[0]
            if option[0] == 'mode':
                if not option[1] in ['enable', 'disable', 'auto']:
                    return False, "Invalid DRC mode: %s" % option[1]
            elif option[0] in ['x', 'y']:
                try:
                    float(option[1])
                except ValueError:
                    return False, ("Invalid value, expected number in "
                                   "range <0.0-1.0>")
                if not 1 >= float(option[1]) >= 0:
                    return False, ("Invalid value of %s parameter, expected "
                                   "number in range <0.0-1.0>" % option[0])

    if args.config is not None:
        try:
            with open(args.config, 'r') as f:
                json_content = f.read()
            configuration = json.loads(json_content)
        except FileNotFoundError:
            return False, "Cannot open input config file: %s" % args.config

        try:
            conf_serialized = configuration['global']['use-serialized-settings']
            profile = configuration['global']['profile']
        except KeyError:
            return False, "Malformed input configuration file."

        if conf_serialized is True and args.speakers != 'lr':
            return False, ("Serialized configuration cannot be used together "
                           "with speaker presence.")

        if (profile != "default" and profile != "off") and (("enable" in args.drc) or ("auto" in args.drc)):
            return False, ("If postprocessing is enabled, "
                           "DRC must be disabled.")

        if (configuration['virtualizer-settings']['height-filter-enable'] ==
                True ) and ('lre' not in args.speakers):
            return False, ("Height filter requires Dolby Atmos "
                            "enabled speakers")

        if (configuration['virtualizer-settings']['surround-speaker-angle'] !=
                0 ) and ('lrs' not in args.speakers):
            return False, ("Surround speaker angle cannot be set if Left/Right "
                            "surround speakers are not present.")

        if (configuration['virtualizer-settings']['rear-surround-speaker-angle']
                != 0 ) and ('lrrs' not in args.speakers):
            return False, ("Rear surround speaker angle cannot be set if Left/Right "
                            "surround speakers are not present.")

        if (configuration['virtualizer-settings']['height-speaker-angle'] !=
                0 ) and (('lre' not in args.speakers) and ('lrtf' not in args.speakers) and ('lrtm' not in args.speakers)):
            return False, ("Height speaker angle cannot be set if Left/Right "
                            "Dolby Atmos enabled speakers or Left/Right top middle "
                            " or Left/Right top front speakers are not present.")

        if (configuration['virtualizer-settings']['rear-height-speaker-angle']
                != 0 ) and (('lrse' not in args.speakers) and ('lrrse' not in args.speakers) and ('lrtr' not in args.speakers)):
            return False, ("Rear height speaker angle cannot be set if Left/Right "
                            "surround Dolby Atmos enable speakers or Left/Right "
                            "rear surround Dolby Atmos enabled speakers or "
                            "Left/Right top rear speakers are not present.")


    if args.xml_config is not None:
        for sets in args.xml_config.split(':'):
            option = sets.split('=')
            if not option[0] in ['file', 'endpoint', 'profile', 'virt']:
                return False, "Invalid option: %s" % option[0]
            if option[0] == 'file':
                if not os.path.isfile(option[1]):
                    return False, ("Cannot open input XML configuration "
                                   "file: %s" % args.xml_config)
            elif option[0] == ['virt']:
                if not option[1] in ['enable', 'disable']:
                    return False, "Invalid virtualizer setting: " % option[1]

            elif option[0] == 'profile':
                if (option[1] not in ["default","off"]) and ("enable" in args.drc or "auto" in args.drc):
                    return False, ("If postprocessing is enabled, "
                                    "DRC must be disabled.")

        if args.speakers != 'lr':
            return False, ("Configuration file cannot be used together with "
                           "speaker presence.")

    return True, "OK"


def create_settings(args):
    """Runs a validation on command line arguments, and creates a structure
    of settings for the pipeline.

    Args:
        args: A ::class::`argparse.Namespace` instance with command line
            arguments and their values.

    Returns:
        settings: A ::class::`gst_home_audio_settings` instance with settings
            for the pipeline.
        json_path: An absolute path to the JSON configuration file, or an
            empty string if the configuration was not used.
    """
    ret, msg = validate_command_line(args)
    assert ret, "Invalid Dolby Atmos processing options.\n%s\n" % msg

    json_path = None
    virt_enable = False
    if args.config is not None:
        with open(args.config, 'r') as f:
            json_content = f.read()
            configuration = json.loads(json_content)
            if configuration['global']['use-serialized-settings']:
                args.speakers = ""
            if configuration['global']['virtualizer-enable']:
                virt_enable = True
        json_path = os.path.abspath(args.config)
    elif args.xml_config is not None:
        xml_path, endpoint, profile = [None] * 3
        for sets in args.xml_config.split(':'):
            option = sets.split('=')
            if option[0] == 'file':
                xml_path = os.path.abspath(option[1])
            elif option[0] == 'endpoint':
                endpoint = option[1]
            elif option[0] == 'profile':
                profile = option[1]
            elif option[0] == 'virt' and option[1] == 'enable':
                virt_enable = True

        # Write converted json file to the same location as output file.
        output_path = os.path.split(os.path.abspath(args.output))[0]
        json_path = os.path.join(output_path, 'config.json')
        xml_to_json(xml_path,
                    json_path,
                    endpoint,
                    virt_enable,
                    profile)
        args.speakers = ""

    settings = gst_home_audio_settings()
    settings.create_from_args(args)
    if virt_enable:
        settings.global_settings.virtualizer_enable = True

    return (settings,
            json_path)


def gst_debug(level):
    """Sets Gstreamer debug output

    Args:
        level : Gstreamer debug level.
    """
    if level:
        Gst.debug_set_active(True)
        Gst.debug_set_default_threshold(level)

def run_pipeline(plugin_path, settings, json_config, filename):
    """Creates and runs the Gstreamer pipeline.

    Args:
        plugin_path: An absolute path to the directory with
            Gstreamer plugins.
        settings: A ::class::`gst_home_audio_settings` instance with
            settings for the pipeline.
        json_config: An absolute path to the JSON configuration file,
            or an empty string, if the configuration is not used.
    """
    pipeline = GstHomeAudioPipeline(plugin_path,
                                    settings,
                                    json_config)
    if filename:
        pipeline.debug_pipeline_to_file(filename)

    pipeline.run()


def convert_xml(args):
    """Converts the input XML configuration file to a set of JSON configuration
    files, one for each endpoint. The output file name provided in the command
    line is appended by the name of the endpoint found in XML,
    e.g. `output.json` becomes `output-internal_speaker.json`

    Args:
        args: A ::class::`argparse.Namespace` instance with command line
            arguments and their values.
    """

    ret, msg = validate_command_line(args)
    assert ret, "Invalid Dolby Atmos processing options.\n%s\n" % msg

    print("\nConverting input XML file: %s\n" % args.input)

    input_file = os.path.abspath(args.input)
    output_file = os.path.abspath(args.output)

    endpoints = get_endpoints(input_file)

    assert endpoints, ("Error processing XML configuration file!\n"
                       "Endpoints not found in the file. The input file may "
                       "be malformed or invalid.")

    for endpoint in endpoints:
        path, ext = os.path.splitext(output_file)
        endpoint_ofile = path + '-' + endpoint + ext
        xml_to_json(ifile=input_file,
                    ofile=endpoint_ofile,
                    endpoint=endpoint,
                    virt_enable=True)
        print("\nWrote output file %s\n" % endpoint_ofile)
